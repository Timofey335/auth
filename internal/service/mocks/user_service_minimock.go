// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Timofey335/auth/internal/service.UserService -o user_service_minimock.go -n UserServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Timofey335/auth/internal/model"
	"github.com/gojuno/minimock/v3"
	"google.golang.org/protobuf/types/known/emptypb"
)

// UserServiceMock implements service.UserService
type UserServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, user *model.UserModel) (i1 int64, err error)
	inspectFuncCreateUser   func(ctx context.Context, user *model.UserModel)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUserServiceMockCreateUser

	funcDeleteUser          func(ctx context.Context, userId int64) (ep1 *emptypb.Empty, err error)
	inspectFuncDeleteUser   func(ctx context.Context, userId int64)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mUserServiceMockDeleteUser

	funcGetAccessToken          func(ctx context.Context, refreshToken string) (s1 string, err error)
	inspectFuncGetAccessToken   func(ctx context.Context, refreshToken string)
	afterGetAccessTokenCounter  uint64
	beforeGetAccessTokenCounter uint64
	GetAccessTokenMock          mUserServiceMockGetAccessToken

	funcGetRefreshToken          func(ctx context.Context, token string) (s1 string, err error)
	inspectFuncGetRefreshToken   func(ctx context.Context, token string)
	afterGetRefreshTokenCounter  uint64
	beforeGetRefreshTokenCounter uint64
	GetRefreshTokenMock          mUserServiceMockGetRefreshToken

	funcGetUser          func(ctx context.Context, userId int64) (up1 *model.UserModel, err error)
	inspectFuncGetUser   func(ctx context.Context, userId int64)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mUserServiceMockGetUser

	funcLogin          func(ctx context.Context, userLoginData *model.UserLoginModel) (s1 string, err error)
	inspectFuncLogin   func(ctx context.Context, userLoginData *model.UserLoginModel)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mUserServiceMockLogin

	funcUpdateUser          func(ctx context.Context, user *model.UserUpdateModel) (ep1 *emptypb.Empty, err error)
	inspectFuncUpdateUser   func(ctx context.Context, user *model.UserUpdateModel)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mUserServiceMockUpdateUser
}

// NewUserServiceMock returns a mock for service.UserService
func NewUserServiceMock(t minimock.Tester) *UserServiceMock {
	m := &UserServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mUserServiceMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UserServiceMockCreateUserParams{}

	m.DeleteUserMock = mUserServiceMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*UserServiceMockDeleteUserParams{}

	m.GetAccessTokenMock = mUserServiceMockGetAccessToken{mock: m}
	m.GetAccessTokenMock.callArgs = []*UserServiceMockGetAccessTokenParams{}

	m.GetRefreshTokenMock = mUserServiceMockGetRefreshToken{mock: m}
	m.GetRefreshTokenMock.callArgs = []*UserServiceMockGetRefreshTokenParams{}

	m.GetUserMock = mUserServiceMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*UserServiceMockGetUserParams{}

	m.LoginMock = mUserServiceMockLogin{mock: m}
	m.LoginMock.callArgs = []*UserServiceMockLoginParams{}

	m.UpdateUserMock = mUserServiceMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*UserServiceMockUpdateUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserServiceMockCreateUser struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockCreateUserExpectation
	expectations       []*UserServiceMockCreateUserExpectation

	callArgs []*UserServiceMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockCreateUserExpectation specifies expectation struct of the UserService.CreateUser
type UserServiceMockCreateUserExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockCreateUserParams
	paramPtrs *UserServiceMockCreateUserParamPtrs
	results   *UserServiceMockCreateUserResults
	Counter   uint64
}

// UserServiceMockCreateUserParams contains parameters of the UserService.CreateUser
type UserServiceMockCreateUserParams struct {
	ctx  context.Context
	user *model.UserModel
}

// UserServiceMockCreateUserParamPtrs contains pointers to parameters of the UserService.CreateUser
type UserServiceMockCreateUserParamPtrs struct {
	ctx  *context.Context
	user **model.UserModel
}

// UserServiceMockCreateUserResults contains results of the UserService.CreateUser
type UserServiceMockCreateUserResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserServiceMockCreateUser) Optional() *mUserServiceMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) Expect(ctx context.Context, user *model.UserModel) *mUserServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &UserServiceMockCreateUserParams{ctx, user}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserServiceMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateUser
}

// ExpectUserParam2 sets up expected param user for UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) ExpectUserParam2(user *model.UserModel) *mUserServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserServiceMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.user = &user

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) Inspect(f func(ctx context.Context, user *model.UserModel)) *mUserServiceMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserServiceMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) Return(i1 int64, err error) *UserServiceMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserServiceMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UserServiceMockCreateUserResults{i1, err}
	return mmCreateUser.mock
}

// Set uses given function f to mock the UserService.CreateUser method
func (mmCreateUser *mUserServiceMockCreateUser) Set(f func(ctx context.Context, user *model.UserModel) (i1 int64, err error)) *UserServiceMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the UserService.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the UserService.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the UserService.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserServiceMockCreateUser) When(ctx context.Context, user *model.UserModel) *UserServiceMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
	}

	expectation := &UserServiceMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &UserServiceMockCreateUserParams{ctx, user},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up UserService.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserServiceMockCreateUserExpectation) Then(i1 int64, err error) *UserServiceMock {
	e.results = &UserServiceMockCreateUserResults{i1, err}
	return e.mock
}

// Times sets number of times UserService.CreateUser should be invoked
func (mmCreateUser *mUserServiceMockCreateUser) Times(n uint64) *mUserServiceMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of UserServiceMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	return mmCreateUser
}

func (mmCreateUser *mUserServiceMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements service.UserService
func (mmCreateUser *UserServiceMock) CreateUser(ctx context.Context, user *model.UserModel) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, user)
	}

	mm_params := UserServiceMockCreateUserParams{ctx, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockCreateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("UserServiceMock.CreateUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateUser.t.Errorf("UserServiceMock.CreateUser got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UserServiceMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the UserServiceMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UserServiceMock.CreateUser. %v %v", ctx, user)
	return
}

// CreateUserAfterCounter returns a count of finished UserServiceMock.CreateUser invocations
func (mmCreateUser *UserServiceMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UserServiceMock.CreateUser invocations
func (mmCreateUser *UserServiceMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserServiceMockCreateUser) Calls() []*UserServiceMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UserServiceMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserServiceMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.CreateUser with params: %#v", *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.CreateUser")
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.CreateUser but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), afterCreateUserCounter)
	}
}

type mUserServiceMockDeleteUser struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockDeleteUserExpectation
	expectations       []*UserServiceMockDeleteUserExpectation

	callArgs []*UserServiceMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockDeleteUserExpectation specifies expectation struct of the UserService.DeleteUser
type UserServiceMockDeleteUserExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockDeleteUserParams
	paramPtrs *UserServiceMockDeleteUserParamPtrs
	results   *UserServiceMockDeleteUserResults
	Counter   uint64
}

// UserServiceMockDeleteUserParams contains parameters of the UserService.DeleteUser
type UserServiceMockDeleteUserParams struct {
	ctx    context.Context
	userId int64
}

// UserServiceMockDeleteUserParamPtrs contains pointers to parameters of the UserService.DeleteUser
type UserServiceMockDeleteUserParamPtrs struct {
	ctx    *context.Context
	userId *int64
}

// UserServiceMockDeleteUserResults contains results of the UserService.DeleteUser
type UserServiceMockDeleteUserResults struct {
	ep1 *emptypb.Empty
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mUserServiceMockDeleteUser) Optional() *mUserServiceMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) Expect(ctx context.Context, userId int64) *mUserServiceMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserServiceMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &UserServiceMockDeleteUserParams{ctx, userId}
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mUserServiceMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserServiceMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserServiceMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteUser
}

// ExpectUserIdParam2 sets up expected param userId for UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) ExpectUserIdParam2(userId int64) *mUserServiceMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserServiceMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserServiceMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.userId = &userId

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) Inspect(f func(ctx context.Context, userId int64)) *mUserServiceMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for UserServiceMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) Return(ep1 *emptypb.Empty, err error) *UserServiceMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserServiceMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &UserServiceMockDeleteUserResults{ep1, err}
	return mmDeleteUser.mock
}

// Set uses given function f to mock the UserService.DeleteUser method
func (mmDeleteUser *mUserServiceMockDeleteUser) Set(f func(ctx context.Context, userId int64) (ep1 *emptypb.Empty, err error)) *UserServiceMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the UserService.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the UserService.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	return mmDeleteUser.mock
}

// When sets expectation for the UserService.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mUserServiceMockDeleteUser) When(ctx context.Context, userId int64) *UserServiceMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
	}

	expectation := &UserServiceMockDeleteUserExpectation{
		mock:   mmDeleteUser.mock,
		params: &UserServiceMockDeleteUserParams{ctx, userId},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up UserService.DeleteUser return parameters for the expectation previously defined by the When method
func (e *UserServiceMockDeleteUserExpectation) Then(ep1 *emptypb.Empty, err error) *UserServiceMock {
	e.results = &UserServiceMockDeleteUserResults{ep1, err}
	return e.mock
}

// Times sets number of times UserService.DeleteUser should be invoked
func (mmDeleteUser *mUserServiceMockDeleteUser) Times(n uint64) *mUserServiceMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of UserServiceMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	return mmDeleteUser
}

func (mmDeleteUser *mUserServiceMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements service.UserService
func (mmDeleteUser *UserServiceMock) DeleteUser(ctx context.Context, userId int64) (ep1 *emptypb.Empty, err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, userId)
	}

	mm_params := UserServiceMockDeleteUserParams{ctx, userId}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockDeleteUserParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("UserServiceMock.DeleteUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmDeleteUser.t.Errorf("UserServiceMock.DeleteUser got unexpected parameter userId, want: %#v, got: %#v%s\n", *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("UserServiceMock.DeleteUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the UserServiceMock.DeleteUser")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, userId)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to UserServiceMock.DeleteUser. %v %v", ctx, userId)
	return
}

// DeleteUserAfterCounter returns a count of finished UserServiceMock.DeleteUser invocations
func (mmDeleteUser *UserServiceMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of UserServiceMock.DeleteUser invocations
func (mmDeleteUser *UserServiceMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mUserServiceMockDeleteUser) Calls() []*UserServiceMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*UserServiceMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *UserServiceMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.DeleteUser with params: %#v", *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.DeleteUser")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.DeleteUser with params: %#v", *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.DeleteUser")
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.DeleteUser but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), afterDeleteUserCounter)
	}
}

type mUserServiceMockGetAccessToken struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockGetAccessTokenExpectation
	expectations       []*UserServiceMockGetAccessTokenExpectation

	callArgs []*UserServiceMockGetAccessTokenParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockGetAccessTokenExpectation specifies expectation struct of the UserService.GetAccessToken
type UserServiceMockGetAccessTokenExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockGetAccessTokenParams
	paramPtrs *UserServiceMockGetAccessTokenParamPtrs
	results   *UserServiceMockGetAccessTokenResults
	Counter   uint64
}

// UserServiceMockGetAccessTokenParams contains parameters of the UserService.GetAccessToken
type UserServiceMockGetAccessTokenParams struct {
	ctx          context.Context
	refreshToken string
}

// UserServiceMockGetAccessTokenParamPtrs contains pointers to parameters of the UserService.GetAccessToken
type UserServiceMockGetAccessTokenParamPtrs struct {
	ctx          *context.Context
	refreshToken *string
}

// UserServiceMockGetAccessTokenResults contains results of the UserService.GetAccessToken
type UserServiceMockGetAccessTokenResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Optional() *mUserServiceMockGetAccessToken {
	mmGetAccessToken.optional = true
	return mmGetAccessToken
}

// Expect sets up expected params for UserService.GetAccessToken
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Expect(ctx context.Context, refreshToken string) *mUserServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &UserServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by ExpectParams functions")
	}

	mmGetAccessToken.defaultExpectation.params = &UserServiceMockGetAccessTokenParams{ctx, refreshToken}
	for _, e := range mmGetAccessToken.expectations {
		if minimock.Equal(e.params, mmGetAccessToken.defaultExpectation.params) {
			mmGetAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAccessToken.defaultExpectation.params)
		}
	}

	return mmGetAccessToken
}

// ExpectCtxParam1 sets up expected param ctx for UserService.GetAccessToken
func (mmGetAccessToken *mUserServiceMockGetAccessToken) ExpectCtxParam1(ctx context.Context) *mUserServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &UserServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.params != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Expect")
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs == nil {
		mmGetAccessToken.defaultExpectation.paramPtrs = &UserServiceMockGetAccessTokenParamPtrs{}
	}
	mmGetAccessToken.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetAccessToken
}

// ExpectRefreshTokenParam2 sets up expected param refreshToken for UserService.GetAccessToken
func (mmGetAccessToken *mUserServiceMockGetAccessToken) ExpectRefreshTokenParam2(refreshToken string) *mUserServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &UserServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.params != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Expect")
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs == nil {
		mmGetAccessToken.defaultExpectation.paramPtrs = &UserServiceMockGetAccessTokenParamPtrs{}
	}
	mmGetAccessToken.defaultExpectation.paramPtrs.refreshToken = &refreshToken

	return mmGetAccessToken
}

// Inspect accepts an inspector function that has same arguments as the UserService.GetAccessToken
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Inspect(f func(ctx context.Context, refreshToken string)) *mUserServiceMockGetAccessToken {
	if mmGetAccessToken.mock.inspectFuncGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("Inspect function is already set for UserServiceMock.GetAccessToken")
	}

	mmGetAccessToken.mock.inspectFuncGetAccessToken = f

	return mmGetAccessToken
}

// Return sets up results that will be returned by UserService.GetAccessToken
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Return(s1 string, err error) *UserServiceMock {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &UserServiceMockGetAccessTokenExpectation{mock: mmGetAccessToken.mock}
	}
	mmGetAccessToken.defaultExpectation.results = &UserServiceMockGetAccessTokenResults{s1, err}
	return mmGetAccessToken.mock
}

// Set uses given function f to mock the UserService.GetAccessToken method
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Set(f func(ctx context.Context, refreshToken string) (s1 string, err error)) *UserServiceMock {
	if mmGetAccessToken.defaultExpectation != nil {
		mmGetAccessToken.mock.t.Fatalf("Default expectation is already set for the UserService.GetAccessToken method")
	}

	if len(mmGetAccessToken.expectations) > 0 {
		mmGetAccessToken.mock.t.Fatalf("Some expectations are already set for the UserService.GetAccessToken method")
	}

	mmGetAccessToken.mock.funcGetAccessToken = f
	return mmGetAccessToken.mock
}

// When sets expectation for the UserService.GetAccessToken which will trigger the result defined by the following
// Then helper
func (mmGetAccessToken *mUserServiceMockGetAccessToken) When(ctx context.Context, refreshToken string) *UserServiceMockGetAccessTokenExpectation {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Set")
	}

	expectation := &UserServiceMockGetAccessTokenExpectation{
		mock:   mmGetAccessToken.mock,
		params: &UserServiceMockGetAccessTokenParams{ctx, refreshToken},
	}
	mmGetAccessToken.expectations = append(mmGetAccessToken.expectations, expectation)
	return expectation
}

// Then sets up UserService.GetAccessToken return parameters for the expectation previously defined by the When method
func (e *UserServiceMockGetAccessTokenExpectation) Then(s1 string, err error) *UserServiceMock {
	e.results = &UserServiceMockGetAccessTokenResults{s1, err}
	return e.mock
}

// Times sets number of times UserService.GetAccessToken should be invoked
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Times(n uint64) *mUserServiceMockGetAccessToken {
	if n == 0 {
		mmGetAccessToken.mock.t.Fatalf("Times of UserServiceMock.GetAccessToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAccessToken.expectedInvocations, n)
	return mmGetAccessToken
}

func (mmGetAccessToken *mUserServiceMockGetAccessToken) invocationsDone() bool {
	if len(mmGetAccessToken.expectations) == 0 && mmGetAccessToken.defaultExpectation == nil && mmGetAccessToken.mock.funcGetAccessToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAccessToken.mock.afterGetAccessTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAccessToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAccessToken implements service.UserService
func (mmGetAccessToken *UserServiceMock) GetAccessToken(ctx context.Context, refreshToken string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetAccessToken.beforeGetAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAccessToken.afterGetAccessTokenCounter, 1)

	if mmGetAccessToken.inspectFuncGetAccessToken != nil {
		mmGetAccessToken.inspectFuncGetAccessToken(ctx, refreshToken)
	}

	mm_params := UserServiceMockGetAccessTokenParams{ctx, refreshToken}

	// Record call args
	mmGetAccessToken.GetAccessTokenMock.mutex.Lock()
	mmGetAccessToken.GetAccessTokenMock.callArgs = append(mmGetAccessToken.GetAccessTokenMock.callArgs, &mm_params)
	mmGetAccessToken.GetAccessTokenMock.mutex.Unlock()

	for _, e := range mmGetAccessToken.GetAccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetAccessToken.GetAccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAccessToken.GetAccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockGetAccessTokenParams{ctx, refreshToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAccessToken.t.Errorf("UserServiceMock.GetAccessToken got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.refreshToken != nil && !minimock.Equal(*mm_want_ptrs.refreshToken, mm_got.refreshToken) {
				mmGetAccessToken.t.Errorf("UserServiceMock.GetAccessToken got unexpected parameter refreshToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.refreshToken, mm_got.refreshToken, minimock.Diff(*mm_want_ptrs.refreshToken, mm_got.refreshToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAccessToken.t.Errorf("UserServiceMock.GetAccessToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAccessToken.t.Fatal("No results are set for the UserServiceMock.GetAccessToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetAccessToken.funcGetAccessToken != nil {
		return mmGetAccessToken.funcGetAccessToken(ctx, refreshToken)
	}
	mmGetAccessToken.t.Fatalf("Unexpected call to UserServiceMock.GetAccessToken. %v %v", ctx, refreshToken)
	return
}

// GetAccessTokenAfterCounter returns a count of finished UserServiceMock.GetAccessToken invocations
func (mmGetAccessToken *UserServiceMock) GetAccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessToken.afterGetAccessTokenCounter)
}

// GetAccessTokenBeforeCounter returns a count of UserServiceMock.GetAccessToken invocations
func (mmGetAccessToken *UserServiceMock) GetAccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessToken.beforeGetAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.GetAccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Calls() []*UserServiceMockGetAccessTokenParams {
	mmGetAccessToken.mutex.RLock()

	argCopy := make([]*UserServiceMockGetAccessTokenParams, len(mmGetAccessToken.callArgs))
	copy(argCopy, mmGetAccessToken.callArgs)

	mmGetAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetAccessTokenDone returns true if the count of the GetAccessToken invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockGetAccessTokenDone() bool {
	if m.GetAccessTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAccessTokenMock.invocationsDone()
}

// MinimockGetAccessTokenInspect logs each unmet expectation
func (m *UserServiceMock) MinimockGetAccessTokenInspect() {
	for _, e := range m.GetAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.GetAccessToken with params: %#v", *e.params)
		}
	}

	afterGetAccessTokenCounter := mm_atomic.LoadUint64(&m.afterGetAccessTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAccessTokenMock.defaultExpectation != nil && afterGetAccessTokenCounter < 1 {
		if m.GetAccessTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.GetAccessToken")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.GetAccessToken with params: %#v", *m.GetAccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAccessToken != nil && afterGetAccessTokenCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.GetAccessToken")
	}

	if !m.GetAccessTokenMock.invocationsDone() && afterGetAccessTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.GetAccessToken but found %d calls",
			mm_atomic.LoadUint64(&m.GetAccessTokenMock.expectedInvocations), afterGetAccessTokenCounter)
	}
}

type mUserServiceMockGetRefreshToken struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockGetRefreshTokenExpectation
	expectations       []*UserServiceMockGetRefreshTokenExpectation

	callArgs []*UserServiceMockGetRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockGetRefreshTokenExpectation specifies expectation struct of the UserService.GetRefreshToken
type UserServiceMockGetRefreshTokenExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockGetRefreshTokenParams
	paramPtrs *UserServiceMockGetRefreshTokenParamPtrs
	results   *UserServiceMockGetRefreshTokenResults
	Counter   uint64
}

// UserServiceMockGetRefreshTokenParams contains parameters of the UserService.GetRefreshToken
type UserServiceMockGetRefreshTokenParams struct {
	ctx   context.Context
	token string
}

// UserServiceMockGetRefreshTokenParamPtrs contains pointers to parameters of the UserService.GetRefreshToken
type UserServiceMockGetRefreshTokenParamPtrs struct {
	ctx   *context.Context
	token *string
}

// UserServiceMockGetRefreshTokenResults contains results of the UserService.GetRefreshToken
type UserServiceMockGetRefreshTokenResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Optional() *mUserServiceMockGetRefreshToken {
	mmGetRefreshToken.optional = true
	return mmGetRefreshToken
}

// Expect sets up expected params for UserService.GetRefreshToken
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Expect(ctx context.Context, token string) *mUserServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &UserServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by ExpectParams functions")
	}

	mmGetRefreshToken.defaultExpectation.params = &UserServiceMockGetRefreshTokenParams{ctx, token}
	for _, e := range mmGetRefreshToken.expectations {
		if minimock.Equal(e.params, mmGetRefreshToken.defaultExpectation.params) {
			mmGetRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRefreshToken.defaultExpectation.params)
		}
	}

	return mmGetRefreshToken
}

// ExpectCtxParam1 sets up expected param ctx for UserService.GetRefreshToken
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) ExpectCtxParam1(ctx context.Context) *mUserServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &UserServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.params != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Expect")
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs == nil {
		mmGetRefreshToken.defaultExpectation.paramPtrs = &UserServiceMockGetRefreshTokenParamPtrs{}
	}
	mmGetRefreshToken.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetRefreshToken
}

// ExpectTokenParam2 sets up expected param token for UserService.GetRefreshToken
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) ExpectTokenParam2(token string) *mUserServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &UserServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.params != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Expect")
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs == nil {
		mmGetRefreshToken.defaultExpectation.paramPtrs = &UserServiceMockGetRefreshTokenParamPtrs{}
	}
	mmGetRefreshToken.defaultExpectation.paramPtrs.token = &token

	return mmGetRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the UserService.GetRefreshToken
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Inspect(f func(ctx context.Context, token string)) *mUserServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.inspectFuncGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("Inspect function is already set for UserServiceMock.GetRefreshToken")
	}

	mmGetRefreshToken.mock.inspectFuncGetRefreshToken = f

	return mmGetRefreshToken
}

// Return sets up results that will be returned by UserService.GetRefreshToken
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Return(s1 string, err error) *UserServiceMock {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &UserServiceMockGetRefreshTokenExpectation{mock: mmGetRefreshToken.mock}
	}
	mmGetRefreshToken.defaultExpectation.results = &UserServiceMockGetRefreshTokenResults{s1, err}
	return mmGetRefreshToken.mock
}

// Set uses given function f to mock the UserService.GetRefreshToken method
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Set(f func(ctx context.Context, token string) (s1 string, err error)) *UserServiceMock {
	if mmGetRefreshToken.defaultExpectation != nil {
		mmGetRefreshToken.mock.t.Fatalf("Default expectation is already set for the UserService.GetRefreshToken method")
	}

	if len(mmGetRefreshToken.expectations) > 0 {
		mmGetRefreshToken.mock.t.Fatalf("Some expectations are already set for the UserService.GetRefreshToken method")
	}

	mmGetRefreshToken.mock.funcGetRefreshToken = f
	return mmGetRefreshToken.mock
}

// When sets expectation for the UserService.GetRefreshToken which will trigger the result defined by the following
// Then helper
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) When(ctx context.Context, token string) *UserServiceMockGetRefreshTokenExpectation {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Set")
	}

	expectation := &UserServiceMockGetRefreshTokenExpectation{
		mock:   mmGetRefreshToken.mock,
		params: &UserServiceMockGetRefreshTokenParams{ctx, token},
	}
	mmGetRefreshToken.expectations = append(mmGetRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up UserService.GetRefreshToken return parameters for the expectation previously defined by the When method
func (e *UserServiceMockGetRefreshTokenExpectation) Then(s1 string, err error) *UserServiceMock {
	e.results = &UserServiceMockGetRefreshTokenResults{s1, err}
	return e.mock
}

// Times sets number of times UserService.GetRefreshToken should be invoked
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Times(n uint64) *mUserServiceMockGetRefreshToken {
	if n == 0 {
		mmGetRefreshToken.mock.t.Fatalf("Times of UserServiceMock.GetRefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRefreshToken.expectedInvocations, n)
	return mmGetRefreshToken
}

func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) invocationsDone() bool {
	if len(mmGetRefreshToken.expectations) == 0 && mmGetRefreshToken.defaultExpectation == nil && mmGetRefreshToken.mock.funcGetRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRefreshToken.mock.afterGetRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRefreshToken implements service.UserService
func (mmGetRefreshToken *UserServiceMock) GetRefreshToken(ctx context.Context, token string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetRefreshToken.beforeGetRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRefreshToken.afterGetRefreshTokenCounter, 1)

	if mmGetRefreshToken.inspectFuncGetRefreshToken != nil {
		mmGetRefreshToken.inspectFuncGetRefreshToken(ctx, token)
	}

	mm_params := UserServiceMockGetRefreshTokenParams{ctx, token}

	// Record call args
	mmGetRefreshToken.GetRefreshTokenMock.mutex.Lock()
	mmGetRefreshToken.GetRefreshTokenMock.callArgs = append(mmGetRefreshToken.GetRefreshTokenMock.callArgs, &mm_params)
	mmGetRefreshToken.GetRefreshTokenMock.mutex.Unlock()

	for _, e := range mmGetRefreshToken.GetRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockGetRefreshTokenParams{ctx, token}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRefreshToken.t.Errorf("UserServiceMock.GetRefreshToken got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.token != nil && !minimock.Equal(*mm_want_ptrs.token, mm_got.token) {
				mmGetRefreshToken.t.Errorf("UserServiceMock.GetRefreshToken got unexpected parameter token, want: %#v, got: %#v%s\n", *mm_want_ptrs.token, mm_got.token, minimock.Diff(*mm_want_ptrs.token, mm_got.token))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRefreshToken.t.Errorf("UserServiceMock.GetRefreshToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRefreshToken.t.Fatal("No results are set for the UserServiceMock.GetRefreshToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetRefreshToken.funcGetRefreshToken != nil {
		return mmGetRefreshToken.funcGetRefreshToken(ctx, token)
	}
	mmGetRefreshToken.t.Fatalf("Unexpected call to UserServiceMock.GetRefreshToken. %v %v", ctx, token)
	return
}

// GetRefreshTokenAfterCounter returns a count of finished UserServiceMock.GetRefreshToken invocations
func (mmGetRefreshToken *UserServiceMock) GetRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshToken.afterGetRefreshTokenCounter)
}

// GetRefreshTokenBeforeCounter returns a count of UserServiceMock.GetRefreshToken invocations
func (mmGetRefreshToken *UserServiceMock) GetRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshToken.beforeGetRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.GetRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Calls() []*UserServiceMockGetRefreshTokenParams {
	mmGetRefreshToken.mutex.RLock()

	argCopy := make([]*UserServiceMockGetRefreshTokenParams, len(mmGetRefreshToken.callArgs))
	copy(argCopy, mmGetRefreshToken.callArgs)

	mmGetRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetRefreshTokenDone returns true if the count of the GetRefreshToken invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockGetRefreshTokenDone() bool {
	if m.GetRefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRefreshTokenMock.invocationsDone()
}

// MinimockGetRefreshTokenInspect logs each unmet expectation
func (m *UserServiceMock) MinimockGetRefreshTokenInspect() {
	for _, e := range m.GetRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.GetRefreshToken with params: %#v", *e.params)
		}
	}

	afterGetRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterGetRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefreshTokenMock.defaultExpectation != nil && afterGetRefreshTokenCounter < 1 {
		if m.GetRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.GetRefreshToken")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.GetRefreshToken with params: %#v", *m.GetRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefreshToken != nil && afterGetRefreshTokenCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.GetRefreshToken")
	}

	if !m.GetRefreshTokenMock.invocationsDone() && afterGetRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.GetRefreshToken but found %d calls",
			mm_atomic.LoadUint64(&m.GetRefreshTokenMock.expectedInvocations), afterGetRefreshTokenCounter)
	}
}

type mUserServiceMockGetUser struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockGetUserExpectation
	expectations       []*UserServiceMockGetUserExpectation

	callArgs []*UserServiceMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockGetUserExpectation specifies expectation struct of the UserService.GetUser
type UserServiceMockGetUserExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockGetUserParams
	paramPtrs *UserServiceMockGetUserParamPtrs
	results   *UserServiceMockGetUserResults
	Counter   uint64
}

// UserServiceMockGetUserParams contains parameters of the UserService.GetUser
type UserServiceMockGetUserParams struct {
	ctx    context.Context
	userId int64
}

// UserServiceMockGetUserParamPtrs contains pointers to parameters of the UserService.GetUser
type UserServiceMockGetUserParamPtrs struct {
	ctx    *context.Context
	userId *int64
}

// UserServiceMockGetUserResults contains results of the UserService.GetUser
type UserServiceMockGetUserResults struct {
	up1 *model.UserModel
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mUserServiceMockGetUser) Optional() *mUserServiceMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for UserService.GetUser
func (mmGetUser *mUserServiceMockGetUser) Expect(ctx context.Context, userId int64) *mUserServiceMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserServiceMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &UserServiceMockGetUserParams{ctx, userId}
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for UserService.GetUser
func (mmGetUser *mUserServiceMockGetUser) ExpectCtxParam1(ctx context.Context) *mUserServiceMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserServiceMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserServiceMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetUser
}

// ExpectUserIdParam2 sets up expected param userId for UserService.GetUser
func (mmGetUser *mUserServiceMockGetUser) ExpectUserIdParam2(userId int64) *mUserServiceMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserServiceMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserServiceMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.userId = &userId

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the UserService.GetUser
func (mmGetUser *mUserServiceMockGetUser) Inspect(f func(ctx context.Context, userId int64)) *mUserServiceMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for UserServiceMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by UserService.GetUser
func (mmGetUser *mUserServiceMockGetUser) Return(up1 *model.UserModel, err error) *UserServiceMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserServiceMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &UserServiceMockGetUserResults{up1, err}
	return mmGetUser.mock
}

// Set uses given function f to mock the UserService.GetUser method
func (mmGetUser *mUserServiceMockGetUser) Set(f func(ctx context.Context, userId int64) (up1 *model.UserModel, err error)) *UserServiceMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the UserService.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the UserService.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	return mmGetUser.mock
}

// When sets expectation for the UserService.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mUserServiceMockGetUser) When(ctx context.Context, userId int64) *UserServiceMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Set")
	}

	expectation := &UserServiceMockGetUserExpectation{
		mock:   mmGetUser.mock,
		params: &UserServiceMockGetUserParams{ctx, userId},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up UserService.GetUser return parameters for the expectation previously defined by the When method
func (e *UserServiceMockGetUserExpectation) Then(up1 *model.UserModel, err error) *UserServiceMock {
	e.results = &UserServiceMockGetUserResults{up1, err}
	return e.mock
}

// Times sets number of times UserService.GetUser should be invoked
func (mmGetUser *mUserServiceMockGetUser) Times(n uint64) *mUserServiceMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of UserServiceMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	return mmGetUser
}

func (mmGetUser *mUserServiceMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements service.UserService
func (mmGetUser *UserServiceMock) GetUser(ctx context.Context, userId int64) (up1 *model.UserModel, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, userId)
	}

	mm_params := UserServiceMockGetUserParams{ctx, userId}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockGetUserParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("UserServiceMock.GetUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmGetUser.t.Errorf("UserServiceMock.GetUser got unexpected parameter userId, want: %#v, got: %#v%s\n", *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("UserServiceMock.GetUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the UserServiceMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, userId)
	}
	mmGetUser.t.Fatalf("Unexpected call to UserServiceMock.GetUser. %v %v", ctx, userId)
	return
}

// GetUserAfterCounter returns a count of finished UserServiceMock.GetUser invocations
func (mmGetUser *UserServiceMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of UserServiceMock.GetUser invocations
func (mmGetUser *UserServiceMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mUserServiceMockGetUser) Calls() []*UserServiceMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*UserServiceMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *UserServiceMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.GetUser with params: %#v", *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.GetUser")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.GetUser with params: %#v", *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.GetUser")
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.GetUser but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), afterGetUserCounter)
	}
}

type mUserServiceMockLogin struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockLoginExpectation
	expectations       []*UserServiceMockLoginExpectation

	callArgs []*UserServiceMockLoginParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockLoginExpectation specifies expectation struct of the UserService.Login
type UserServiceMockLoginExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockLoginParams
	paramPtrs *UserServiceMockLoginParamPtrs
	results   *UserServiceMockLoginResults
	Counter   uint64
}

// UserServiceMockLoginParams contains parameters of the UserService.Login
type UserServiceMockLoginParams struct {
	ctx           context.Context
	userLoginData *model.UserLoginModel
}

// UserServiceMockLoginParamPtrs contains pointers to parameters of the UserService.Login
type UserServiceMockLoginParamPtrs struct {
	ctx           *context.Context
	userLoginData **model.UserLoginModel
}

// UserServiceMockLoginResults contains results of the UserService.Login
type UserServiceMockLoginResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogin *mUserServiceMockLogin) Optional() *mUserServiceMockLogin {
	mmLogin.optional = true
	return mmLogin
}

// Expect sets up expected params for UserService.Login
func (mmLogin *mUserServiceMockLogin) Expect(ctx context.Context, userLoginData *model.UserLoginModel) *mUserServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UserServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.paramPtrs != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by ExpectParams functions")
	}

	mmLogin.defaultExpectation.params = &UserServiceMockLoginParams{ctx, userLoginData}
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// ExpectCtxParam1 sets up expected param ctx for UserService.Login
func (mmLogin *mUserServiceMockLogin) ExpectCtxParam1(ctx context.Context) *mUserServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UserServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &UserServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.ctx = &ctx

	return mmLogin
}

// ExpectUserLoginDataParam2 sets up expected param userLoginData for UserService.Login
func (mmLogin *mUserServiceMockLogin) ExpectUserLoginDataParam2(userLoginData *model.UserLoginModel) *mUserServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UserServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &UserServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.userLoginData = &userLoginData

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the UserService.Login
func (mmLogin *mUserServiceMockLogin) Inspect(f func(ctx context.Context, userLoginData *model.UserLoginModel)) *mUserServiceMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by UserService.Login
func (mmLogin *mUserServiceMockLogin) Return(s1 string, err error) *UserServiceMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UserServiceMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &UserServiceMockLoginResults{s1, err}
	return mmLogin.mock
}

// Set uses given function f to mock the UserService.Login method
func (mmLogin *mUserServiceMockLogin) Set(f func(ctx context.Context, userLoginData *model.UserLoginModel) (s1 string, err error)) *UserServiceMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the UserService.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the UserService.Login method")
	}

	mmLogin.mock.funcLogin = f
	return mmLogin.mock
}

// When sets expectation for the UserService.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mUserServiceMockLogin) When(ctx context.Context, userLoginData *model.UserLoginModel) *UserServiceMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Set")
	}

	expectation := &UserServiceMockLoginExpectation{
		mock:   mmLogin.mock,
		params: &UserServiceMockLoginParams{ctx, userLoginData},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up UserService.Login return parameters for the expectation previously defined by the When method
func (e *UserServiceMockLoginExpectation) Then(s1 string, err error) *UserServiceMock {
	e.results = &UserServiceMockLoginResults{s1, err}
	return e.mock
}

// Times sets number of times UserService.Login should be invoked
func (mmLogin *mUserServiceMockLogin) Times(n uint64) *mUserServiceMockLogin {
	if n == 0 {
		mmLogin.mock.t.Fatalf("Times of UserServiceMock.Login mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogin.expectedInvocations, n)
	return mmLogin
}

func (mmLogin *mUserServiceMockLogin) invocationsDone() bool {
	if len(mmLogin.expectations) == 0 && mmLogin.defaultExpectation == nil && mmLogin.mock.funcLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogin.mock.afterLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Login implements service.UserService
func (mmLogin *UserServiceMock) Login(ctx context.Context, userLoginData *model.UserLoginModel) (s1 string, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, userLoginData)
	}

	mm_params := UserServiceMockLoginParams{ctx, userLoginData}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, &mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_want_ptrs := mmLogin.LoginMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockLoginParams{ctx, userLoginData}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogin.t.Errorf("UserServiceMock.Login got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userLoginData != nil && !minimock.Equal(*mm_want_ptrs.userLoginData, mm_got.userLoginData) {
				mmLogin.t.Errorf("UserServiceMock.Login got unexpected parameter userLoginData, want: %#v, got: %#v%s\n", *mm_want_ptrs.userLoginData, mm_got.userLoginData, minimock.Diff(*mm_want_ptrs.userLoginData, mm_got.userLoginData))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("UserServiceMock.Login got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the UserServiceMock.Login")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, userLoginData)
	}
	mmLogin.t.Fatalf("Unexpected call to UserServiceMock.Login. %v %v", ctx, userLoginData)
	return
}

// LoginAfterCounter returns a count of finished UserServiceMock.Login invocations
func (mmLogin *UserServiceMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of UserServiceMock.Login invocations
func (mmLogin *UserServiceMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mUserServiceMockLogin) Calls() []*UserServiceMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*UserServiceMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockLoginDone() bool {
	if m.LoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginMock.invocationsDone()
}

// MinimockLoginInspect logs each unmet expectation
func (m *UserServiceMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Login with params: %#v", *e.params)
		}
	}

	afterLoginCounter := mm_atomic.LoadUint64(&m.afterLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && afterLoginCounter < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.Login")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Login with params: %#v", *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && afterLoginCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.Login")
	}

	if !m.LoginMock.invocationsDone() && afterLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.Login but found %d calls",
			mm_atomic.LoadUint64(&m.LoginMock.expectedInvocations), afterLoginCounter)
	}
}

type mUserServiceMockUpdateUser struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockUpdateUserExpectation
	expectations       []*UserServiceMockUpdateUserExpectation

	callArgs []*UserServiceMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockUpdateUserExpectation specifies expectation struct of the UserService.UpdateUser
type UserServiceMockUpdateUserExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockUpdateUserParams
	paramPtrs *UserServiceMockUpdateUserParamPtrs
	results   *UserServiceMockUpdateUserResults
	Counter   uint64
}

// UserServiceMockUpdateUserParams contains parameters of the UserService.UpdateUser
type UserServiceMockUpdateUserParams struct {
	ctx  context.Context
	user *model.UserUpdateModel
}

// UserServiceMockUpdateUserParamPtrs contains pointers to parameters of the UserService.UpdateUser
type UserServiceMockUpdateUserParamPtrs struct {
	ctx  *context.Context
	user **model.UserUpdateModel
}

// UserServiceMockUpdateUserResults contains results of the UserService.UpdateUser
type UserServiceMockUpdateUserResults struct {
	ep1 *emptypb.Empty
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mUserServiceMockUpdateUser) Optional() *mUserServiceMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) Expect(ctx context.Context, user *model.UserUpdateModel) *mUserServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &UserServiceMockUpdateUserParams{ctx, user}
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mUserServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserServiceMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateUser
}

// ExpectUserParam2 sets up expected param user for UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) ExpectUserParam2(user *model.UserUpdateModel) *mUserServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserServiceMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.user = &user

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) Inspect(f func(ctx context.Context, user *model.UserUpdateModel)) *mUserServiceMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for UserServiceMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) Return(ep1 *emptypb.Empty, err error) *UserServiceMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserServiceMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &UserServiceMockUpdateUserResults{ep1, err}
	return mmUpdateUser.mock
}

// Set uses given function f to mock the UserService.UpdateUser method
func (mmUpdateUser *mUserServiceMockUpdateUser) Set(f func(ctx context.Context, user *model.UserUpdateModel) (ep1 *emptypb.Empty, err error)) *UserServiceMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the UserService.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the UserService.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	return mmUpdateUser.mock
}

// When sets expectation for the UserService.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mUserServiceMockUpdateUser) When(ctx context.Context, user *model.UserUpdateModel) *UserServiceMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
	}

	expectation := &UserServiceMockUpdateUserExpectation{
		mock:   mmUpdateUser.mock,
		params: &UserServiceMockUpdateUserParams{ctx, user},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up UserService.UpdateUser return parameters for the expectation previously defined by the When method
func (e *UserServiceMockUpdateUserExpectation) Then(ep1 *emptypb.Empty, err error) *UserServiceMock {
	e.results = &UserServiceMockUpdateUserResults{ep1, err}
	return e.mock
}

// Times sets number of times UserService.UpdateUser should be invoked
func (mmUpdateUser *mUserServiceMockUpdateUser) Times(n uint64) *mUserServiceMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of UserServiceMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	return mmUpdateUser
}

func (mmUpdateUser *mUserServiceMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements service.UserService
func (mmUpdateUser *UserServiceMock) UpdateUser(ctx context.Context, user *model.UserUpdateModel) (ep1 *emptypb.Empty, err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, user)
	}

	mm_params := UserServiceMockUpdateUserParams{ctx, user}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockUpdateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("UserServiceMock.UpdateUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmUpdateUser.t.Errorf("UserServiceMock.UpdateUser got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("UserServiceMock.UpdateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the UserServiceMock.UpdateUser")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, user)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to UserServiceMock.UpdateUser. %v %v", ctx, user)
	return
}

// UpdateUserAfterCounter returns a count of finished UserServiceMock.UpdateUser invocations
func (mmUpdateUser *UserServiceMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of UserServiceMock.UpdateUser invocations
func (mmUpdateUser *UserServiceMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mUserServiceMockUpdateUser) Calls() []*UserServiceMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*UserServiceMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *UserServiceMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.UpdateUser with params: %#v", *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.UpdateUser")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.UpdateUser with params: %#v", *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.UpdateUser")
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.UpdateUser but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), afterUpdateUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetAccessTokenInspect()

			m.MinimockGetRefreshTokenInspect()

			m.MinimockGetUserInspect()

			m.MinimockLoginInspect()

			m.MinimockUpdateUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetAccessTokenDone() &&
		m.MinimockGetRefreshTokenDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockLoginDone() &&
		m.MinimockUpdateUserDone()
}
