// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Timofey335/auth/internal/cache.UserCache -o user_cache_minimock.go -n UserCacheMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Timofey335/auth/internal/model"
	"github.com/gojuno/minimock/v3"
)

// UserCacheMock implements mm_cache.UserCache
type UserCacheMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, user *model.UserModel) (err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, user *model.UserModel)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUserCacheMockCreateUser

	funcDeleteUser          func(ctx context.Context, id int64) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, id int64)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mUserCacheMockDeleteUser

	funcGetUser          func(ctx context.Context, id int64) (up1 *model.UserModel, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, id int64)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mUserCacheMockGetUser
}

// NewUserCacheMock returns a mock for mm_cache.UserCache
func NewUserCacheMock(t minimock.Tester) *UserCacheMock {
	m := &UserCacheMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mUserCacheMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UserCacheMockCreateUserParams{}

	m.DeleteUserMock = mUserCacheMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*UserCacheMockDeleteUserParams{}

	m.GetUserMock = mUserCacheMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*UserCacheMockGetUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserCacheMockCreateUser struct {
	optional           bool
	mock               *UserCacheMock
	defaultExpectation *UserCacheMockCreateUserExpectation
	expectations       []*UserCacheMockCreateUserExpectation

	callArgs []*UserCacheMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCacheMockCreateUserExpectation specifies expectation struct of the UserCache.CreateUser
type UserCacheMockCreateUserExpectation struct {
	mock               *UserCacheMock
	params             *UserCacheMockCreateUserParams
	paramPtrs          *UserCacheMockCreateUserParamPtrs
	expectationOrigins UserCacheMockCreateUserExpectationOrigins
	results            *UserCacheMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserCacheMockCreateUserParams contains parameters of the UserCache.CreateUser
type UserCacheMockCreateUserParams struct {
	ctx  context.Context
	user *model.UserModel
}

// UserCacheMockCreateUserParamPtrs contains pointers to parameters of the UserCache.CreateUser
type UserCacheMockCreateUserParamPtrs struct {
	ctx  *context.Context
	user **model.UserModel
}

// UserCacheMockCreateUserResults contains results of the UserCache.CreateUser
type UserCacheMockCreateUserResults struct {
	err error
}

// UserCacheMockCreateUserOrigins contains origins of expectations of the UserCache.CreateUser
type UserCacheMockCreateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserCacheMockCreateUser) Optional() *mUserCacheMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for UserCache.CreateUser
func (mmCreateUser *mUserCacheMockCreateUser) Expect(ctx context.Context, user *model.UserModel) *mUserCacheMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserCacheMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserCacheMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("UserCacheMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &UserCacheMockCreateUserParams{ctx, user}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserCache.CreateUser
func (mmCreateUser *mUserCacheMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserCacheMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserCacheMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserCacheMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserCacheMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserCacheMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectUserParam2 sets up expected param user for UserCache.CreateUser
func (mmCreateUser *mUserCacheMockCreateUser) ExpectUserParam2(user *model.UserModel) *mUserCacheMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserCacheMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserCacheMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserCacheMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserCacheMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.user = &user
	mmCreateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the UserCache.CreateUser
func (mmCreateUser *mUserCacheMockCreateUser) Inspect(f func(ctx context.Context, user *model.UserModel)) *mUserCacheMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserCacheMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by UserCache.CreateUser
func (mmCreateUser *mUserCacheMockCreateUser) Return(err error) *UserCacheMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserCacheMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserCacheMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UserCacheMockCreateUserResults{err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the UserCache.CreateUser method
func (mmCreateUser *mUserCacheMockCreateUser) Set(f func(ctx context.Context, user *model.UserModel) (err error)) *UserCacheMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the UserCache.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the UserCache.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the UserCache.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserCacheMockCreateUser) When(ctx context.Context, user *model.UserModel) *UserCacheMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserCacheMock.CreateUser mock is already set by Set")
	}

	expectation := &UserCacheMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &UserCacheMockCreateUserParams{ctx, user},
		expectationOrigins: UserCacheMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up UserCache.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserCacheMockCreateUserExpectation) Then(err error) *UserCacheMock {
	e.results = &UserCacheMockCreateUserResults{err}
	return e.mock
}

// Times sets number of times UserCache.CreateUser should be invoked
func (mmCreateUser *mUserCacheMockCreateUser) Times(n uint64) *mUserCacheMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of UserCacheMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mUserCacheMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_cache.UserCache
func (mmCreateUser *UserCacheMock) CreateUser(ctx context.Context, user *model.UserModel) (err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, user)
	}

	mm_params := UserCacheMockCreateUserParams{ctx, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := UserCacheMockCreateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("UserCacheMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateUser.t.Errorf("UserCacheMock.CreateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UserCacheMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the UserCacheMock.CreateUser")
		}
		return (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UserCacheMock.CreateUser. %v %v", ctx, user)
	return
}

// CreateUserAfterCounter returns a count of finished UserCacheMock.CreateUser invocations
func (mmCreateUser *UserCacheMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UserCacheMock.CreateUser invocations
func (mmCreateUser *UserCacheMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UserCacheMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserCacheMockCreateUser) Calls() []*UserCacheMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UserCacheMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserCacheMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserCacheMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCacheMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCacheMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to UserCacheMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mUserCacheMockDeleteUser struct {
	optional           bool
	mock               *UserCacheMock
	defaultExpectation *UserCacheMockDeleteUserExpectation
	expectations       []*UserCacheMockDeleteUserExpectation

	callArgs []*UserCacheMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCacheMockDeleteUserExpectation specifies expectation struct of the UserCache.DeleteUser
type UserCacheMockDeleteUserExpectation struct {
	mock               *UserCacheMock
	params             *UserCacheMockDeleteUserParams
	paramPtrs          *UserCacheMockDeleteUserParamPtrs
	expectationOrigins UserCacheMockDeleteUserExpectationOrigins
	results            *UserCacheMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// UserCacheMockDeleteUserParams contains parameters of the UserCache.DeleteUser
type UserCacheMockDeleteUserParams struct {
	ctx context.Context
	id  int64
}

// UserCacheMockDeleteUserParamPtrs contains pointers to parameters of the UserCache.DeleteUser
type UserCacheMockDeleteUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserCacheMockDeleteUserResults contains results of the UserCache.DeleteUser
type UserCacheMockDeleteUserResults struct {
	err error
}

// UserCacheMockDeleteUserOrigins contains origins of expectations of the UserCache.DeleteUser
type UserCacheMockDeleteUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mUserCacheMockDeleteUser) Optional() *mUserCacheMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for UserCache.DeleteUser
func (mmDeleteUser *mUserCacheMockDeleteUser) Expect(ctx context.Context, id int64) *mUserCacheMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserCacheMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserCacheMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("UserCacheMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &UserCacheMockDeleteUserParams{ctx, id}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for UserCache.DeleteUser
func (mmDeleteUser *mUserCacheMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mUserCacheMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserCacheMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserCacheMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserCacheMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserCacheMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectIdParam2 sets up expected param id for UserCache.DeleteUser
func (mmDeleteUser *mUserCacheMockDeleteUser) ExpectIdParam2(id int64) *mUserCacheMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserCacheMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserCacheMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserCacheMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserCacheMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.id = &id
	mmDeleteUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the UserCache.DeleteUser
func (mmDeleteUser *mUserCacheMockDeleteUser) Inspect(f func(ctx context.Context, id int64)) *mUserCacheMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for UserCacheMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by UserCache.DeleteUser
func (mmDeleteUser *mUserCacheMockDeleteUser) Return(err error) *UserCacheMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserCacheMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserCacheMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &UserCacheMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the UserCache.DeleteUser method
func (mmDeleteUser *mUserCacheMockDeleteUser) Set(f func(ctx context.Context, id int64) (err error)) *UserCacheMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the UserCache.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the UserCache.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the UserCache.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mUserCacheMockDeleteUser) When(ctx context.Context, id int64) *UserCacheMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserCacheMock.DeleteUser mock is already set by Set")
	}

	expectation := &UserCacheMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &UserCacheMockDeleteUserParams{ctx, id},
		expectationOrigins: UserCacheMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up UserCache.DeleteUser return parameters for the expectation previously defined by the When method
func (e *UserCacheMockDeleteUserExpectation) Then(err error) *UserCacheMock {
	e.results = &UserCacheMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times UserCache.DeleteUser should be invoked
func (mmDeleteUser *mUserCacheMockDeleteUser) Times(n uint64) *mUserCacheMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of UserCacheMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mUserCacheMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_cache.UserCache
func (mmDeleteUser *UserCacheMock) DeleteUser(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, id)
	}

	mm_params := UserCacheMockDeleteUserParams{ctx, id}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := UserCacheMockDeleteUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("UserCacheMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteUser.t.Errorf("UserCacheMock.DeleteUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("UserCacheMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the UserCacheMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, id)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to UserCacheMock.DeleteUser. %v %v", ctx, id)
	return
}

// DeleteUserAfterCounter returns a count of finished UserCacheMock.DeleteUser invocations
func (mmDeleteUser *UserCacheMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of UserCacheMock.DeleteUser invocations
func (mmDeleteUser *UserCacheMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to UserCacheMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mUserCacheMockDeleteUser) Calls() []*UserCacheMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*UserCacheMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *UserCacheMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *UserCacheMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCacheMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCacheMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to UserCacheMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

type mUserCacheMockGetUser struct {
	optional           bool
	mock               *UserCacheMock
	defaultExpectation *UserCacheMockGetUserExpectation
	expectations       []*UserCacheMockGetUserExpectation

	callArgs []*UserCacheMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCacheMockGetUserExpectation specifies expectation struct of the UserCache.GetUser
type UserCacheMockGetUserExpectation struct {
	mock               *UserCacheMock
	params             *UserCacheMockGetUserParams
	paramPtrs          *UserCacheMockGetUserParamPtrs
	expectationOrigins UserCacheMockGetUserExpectationOrigins
	results            *UserCacheMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// UserCacheMockGetUserParams contains parameters of the UserCache.GetUser
type UserCacheMockGetUserParams struct {
	ctx context.Context
	id  int64
}

// UserCacheMockGetUserParamPtrs contains pointers to parameters of the UserCache.GetUser
type UserCacheMockGetUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserCacheMockGetUserResults contains results of the UserCache.GetUser
type UserCacheMockGetUserResults struct {
	up1 *model.UserModel
	err error
}

// UserCacheMockGetUserOrigins contains origins of expectations of the UserCache.GetUser
type UserCacheMockGetUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mUserCacheMockGetUser) Optional() *mUserCacheMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for UserCache.GetUser
func (mmGetUser *mUserCacheMockGetUser) Expect(ctx context.Context, id int64) *mUserCacheMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCacheMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserCacheMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("UserCacheMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &UserCacheMockGetUserParams{ctx, id}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for UserCache.GetUser
func (mmGetUser *mUserCacheMockGetUser) ExpectCtxParam1(ctx context.Context) *mUserCacheMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCacheMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserCacheMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserCacheMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserCacheMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectIdParam2 sets up expected param id for UserCache.GetUser
func (mmGetUser *mUserCacheMockGetUser) ExpectIdParam2(id int64) *mUserCacheMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCacheMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserCacheMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserCacheMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserCacheMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.id = &id
	mmGetUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the UserCache.GetUser
func (mmGetUser *mUserCacheMockGetUser) Inspect(f func(ctx context.Context, id int64)) *mUserCacheMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for UserCacheMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by UserCache.GetUser
func (mmGetUser *mUserCacheMockGetUser) Return(up1 *model.UserModel, err error) *UserCacheMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCacheMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserCacheMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &UserCacheMockGetUserResults{up1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the UserCache.GetUser method
func (mmGetUser *mUserCacheMockGetUser) Set(f func(ctx context.Context, id int64) (up1 *model.UserModel, err error)) *UserCacheMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the UserCache.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the UserCache.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the UserCache.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mUserCacheMockGetUser) When(ctx context.Context, id int64) *UserCacheMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCacheMock.GetUser mock is already set by Set")
	}

	expectation := &UserCacheMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &UserCacheMockGetUserParams{ctx, id},
		expectationOrigins: UserCacheMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up UserCache.GetUser return parameters for the expectation previously defined by the When method
func (e *UserCacheMockGetUserExpectation) Then(up1 *model.UserModel, err error) *UserCacheMock {
	e.results = &UserCacheMockGetUserResults{up1, err}
	return e.mock
}

// Times sets number of times UserCache.GetUser should be invoked
func (mmGetUser *mUserCacheMockGetUser) Times(n uint64) *mUserCacheMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of UserCacheMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mUserCacheMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_cache.UserCache
func (mmGetUser *UserCacheMock) GetUser(ctx context.Context, id int64) (up1 *model.UserModel, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, id)
	}

	mm_params := UserCacheMockGetUserParams{ctx, id}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := UserCacheMockGetUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("UserCacheMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetUser.t.Errorf("UserCacheMock.GetUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("UserCacheMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the UserCacheMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, id)
	}
	mmGetUser.t.Fatalf("Unexpected call to UserCacheMock.GetUser. %v %v", ctx, id)
	return
}

// GetUserAfterCounter returns a count of finished UserCacheMock.GetUser invocations
func (mmGetUser *UserCacheMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of UserCacheMock.GetUser invocations
func (mmGetUser *UserCacheMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to UserCacheMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mUserCacheMockGetUser) Calls() []*UserCacheMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*UserCacheMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *UserCacheMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *UserCacheMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCacheMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCacheMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to UserCacheMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserCacheMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserCacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserCacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetUserDone()
}
